<!--
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Bug Invasion</title>
		<link rel="shortcut icon" href="pics/favicon.ico">
		<link rel="stylesheet" href="style.css">
		<script src="script.js"></script>
	</head>
	<body>
		<header>
			<h1>Bug Invasion</h1>
		</header>
		<div id="game-container">
			<canvas id="game-canvas" width="1200" height="650"></canvas>
		</div>
	</body>
</html>
-->
<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
body {
	color: #fff;
	background-color: #444;
}
canvas {
	margin: 50px auto 0px;
	background-color: #000 !important;
	display: block;
	border: 3px inset #999;
	background-color: #ffffff;
}
#test {
	margin-left: 120px;
}		
</style>
</head>
<body onload="startGame()">
	<img id="player" src="/images/playerShip.png" style="display: none;">
	<p id="test"></p>
<script>
var myGamePiece;
var imageSrc = document.getElementById("player");

function startGame() {
    myGamePiece = new Player(30, 30, "#b22", 400, 300);
    myGameArea.start();
}

var mouse = {x: 400, y: 300};
var angle = 0;
var playerShots = [];
	
var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = 1200;
        this.canvas.height = 700;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.frameNo = 0;
        this.interval = setInterval(updateGameArea, 5);
	    
        window.addEventListener('keydown', function (e) {
		e.preventDefault();
		myGameArea.keys = (myGameArea.keys || []);
		myGameArea.keys[e.keyCode] = (e.type == "keydown");
        })
        window.addEventListener('keyup', function (e) {
		myGameArea.keys[e.keyCode] = (e.type == "keydown");
        })
        this.canvas.addEventListener('mousemove', function (e) {
		var rect = myGameArea.canvas.getBoundingClientRect();
		mouse.x = e.clientX - rect.left;
		mouse.y = e.clientY - rect.top;
        })
	this.canvas.addEventListener('mousedown', function (e) {
		myGamePiece.shoot();
        })
    },
    stop : function() {
        clearInterval(this.interval);
    },    
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function Shot(angle) {
	this.speedX = 7;
	this.speedY = 7;
	this.angle = angle;
	this.x = myGamePiece.x;
	this.y = myGamePiece.y;
	this.width = 5;
	this.height = 5;
	
	this.draw = function() {
		ctx = myGameArea.context;
		ctx.save();
		ctx.translate(this.x, this.y);
		ctx.fillStyle = "#fff";
		ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);
		ctx.rotate(angle);
		ctx.restore();
	}
	
	this.newPos = function() {
		this.x += this.speedX * 1 * Math.sin(angle + (0.5 * Math.PI));
		this.y += this.speedY * -1 * Math.cos(angle + (0.5 * Math.PI));
		
		if ( (this.x < -20) || (this.x > myGameArea.width + 20)
		    || (this.y < - 20) || (this.y > myGameArea.height + 20) ) {
			var index = playerShots.findIndex(this);
			playerShots.splice(index, 1);
		}
	}
}

function Player(width, height, color, x, y, type) {
	this.type = type;
	this.width = width;
	this.height = height;
	this.speedX = 0;
	this.speedY = 0;
	this.friction = 0.99;
	this.accelerationX = 0;
	this.accelerationY = 0;
	this.x = x;
	this.y = y;    
	
	this.update = function() {
		distance = Math.sqrt( Math.pow( mouse.x - this.x, 2 ) + Math.pow( mouse.y - this.y, 2 ) );
		angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);

		document.getElementById("test").innerHTML =
			"Mouse: " + mouse.x + " | " + mouse.y +
			"<br>Player: " + myGamePiece.x + " | " + myGamePiece.y +
			"<br>Angle: " + angle * 180 / Math.PI + "<br>Distance: " + distance +
			"<br>Speed: " + myGamePiece.speedX + " | " +  myGamePiece.speedY +
			"<br>Acceleration: " + myGamePiece.accelerationX + " | " + myGamePiece.accelerationX;
			console.log(playerShots);
		;
		ctx = myGameArea.context;
		myGameArea.clear();
		ctx.save();
		ctx.translate(this.x, this.y);
		ctx.rotate(angle + (90 * Math.PI / 180));
		ctx.drawImage( document.getElementById("player"), -this.width / 2, -this.height / 2 );
		ctx.restore();

		ctx.strokeStyle="#abf";
		ctx.beginPath();
		ctx.arc( mouse.x, mouse.y, distance, 0, 2 * Math.PI);
		ctx.stroke();
		ctx.strokeStyle="#ddd";

		ctx.beginPath();
		ctx.moveTo(myGamePiece.x, myGamePiece.y);
		ctx.lineTo(mouse.x, mouse.y);
		ctx.stroke();
		
		for (shot of playerShots) {
			shot.newPos();
			shot.draw();
		}
	}
	
	this.newPos = function() {
		this.x += this.speedX + this.accelerationX;
		this.y -= this.speedY + this.accelerationY;
	}
	
	this.shoot = function() {
		playerShots.push(new Shot(angle));
	}
}

function updateGameArea() {
	myGameArea.clear();
	myGamePiece.speedX = 0;
	myGamePiece.speedY = 0;
	
	myGamePiece.accelerationX *= myGamePiece.friction;
	myGamePiece.accelerationY *= myGamePiece.friction;
	
	if ( (myGamePiece.accelerationX < 0.01) && (myGamePiece.accelerationX > -0.01) ) {
		myGamePiece.accelerationX = 0;
	}
	if ( (myGamePiece.accelerationY < 0.01) && (myGamePiece.accelerationY > -0.01) ) {
		myGamePiece.accelerationX = 0;
	}
	
	if (myGameArea.keys && myGameArea.keys[87]) {
		if (distance > 10) {
			myGamePiece.speedX += 1 * Math.sin(angle + (0.5 * Math.PI));
			myGamePiece.speedY += 1 * Math.cos(angle + (0.5 * Math.PI));
			
			myGamePiece.accelerationX += 0.03 * Math.sin(angle + (0.5 * Math.PI));
			myGamePiece.accelerationY += 0.03 * Math.cos(angle + (0.5 * Math.PI));
		}
	}

	if (myGameArea.keys && myGameArea.keys[83]) {
		myGamePiece.speedX += -1 * Math.sin(angle + (0.5 * Math.PI));
		myGamePiece.speedY += -1 * Math.cos(angle + (0.5 * Math.PI));
		
		myGamePiece.accelerationX += -0.03 * Math.sin(angle + (0.5 * Math.PI));
		myGamePiece.accelerationY += -0.03 * Math.cos(angle + (0.5 * Math.PI));
	}

	if (myGameArea.keys && myGameArea.keys[65]) {
		if (distance > 10) {
			angle += Math.acos(1 - Math.pow(1 / distance,2) / 2);
			myGamePiece.speedX += 1 * Math.sin(angle + (2 * Math.PI));
			myGamePiece.speedY += 1 * Math.cos(angle + (2 * Math.PI));
			
			myGamePiece.accelerationX += 0.01 * Math.sin(angle + (2 * Math.PI));
			myGamePiece.accelerationY += 0.01 * Math.cos(angle + (2 * Math.PI));
		}
	}

	if (myGameArea.keys && myGameArea.keys[68]) {
		if (distance > 10) {
			angle -= Math.acos(1 - Math.pow(1 / distance,2) / 2);
			myGamePiece.speedX += -1 * Math.sin(angle + (2 * Math.PI));
			myGamePiece.speedY += -1 * Math.cos(angle + (2 * Math.PI));
			
			myGamePiece.accelerationX += -0.01 * Math.sin(angle + (2 * Math.PI));
			myGamePiece.accelerationY += -0.01 * Math.cos(angle + (2 * Math.PI));
		}
	}

	myGamePiece.newPos();
	myGamePiece.update();
}
</script>
</body>
</html>
